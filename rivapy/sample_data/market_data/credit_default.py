import numpy as np
import scipy
import pandas as pd

class CreditDefaultData:
    @staticmethod
    def sample(n_data: int, seed: int=None, constant=-1.0, 
                cov:np.ndarray=None) -> pd.DataFrame:
        """Sample credit default data. 

        Return a pandas DataFrame that contains some credit features together with the default probability
        and an indicator if the default occured (1) or if the credit did not default (0). The data is generated by a logistic regression
        where the pd for a credit is computed by logistic regression (with fixed coefficients). The following features
        are used

        - :math:`x_{\\mbox{age}}` age of lender, sampled from beta distribution (a=2, b=5)
        - :math:`x_{\\mbox{income}}` income of lender, sampled from beta distribution (a=2.0, b=2.0)
        - :math:`x_{\\mbox{savings}}` savings of lender, sampled from beta distribution (a=5.0, b=1.0)
        - :math:`x_{\\mbox{amount}}` amount of credit, sampled from  beta distribution (a=0.5, b=0.5)
        - :math:`x_{\\mbox{region}}` one hot encoded feature indicating  one of three regions the lender lives in. The region are uniformly distributed
        
        The single features (exception is the region that is drawn independently of the other features) are related via a Gaussian copula. The following figure showsthe distributions and pairplots for a 
        generated sample of features.

        .. image:: ../../../docs/source/figs/credit_default_features.png
            :align: center
            :width: 400
  
        After the features have been generated, logistic regression is used to compute default probabilities (pd) via the formula
        
        .. math::
            pd = \\frac{1}{1+e^{x_{\\mbox{age}}}

        Args:
            n_data (int): Number of data sampled (number of rows of final DataFrame).
            seed (int, optional): The seed used internally, if None, no seed will be set. Defaults to None.
            constant (float, optional): Constant used in logistic regression that determines the overall level of the pd. Defaults to -1.0.
            cov (np.ndarray, optional): Covariance matrix used in the Gaussian copula. Defaults to None (thena flat covariance of 0.95 is used).

        Returns:
            pd.DataFrame: DataFrame with features, default probabilities and default indicator.
        """
        if seed is not None:
            np.random.seed(seed)
        if cov is None:
            cov = np.array([[1.0,0.95,0.95,0.95],
                [0.95,1.0,0.95,0.95],
                [0.95,0.95,1.0,0.95],
                [0.95,0.95,0.95,1.0],])
        mean = np.array([0.0,0.0,0.0,0.0])
        x_ = np.random.multivariate_normal(mean=mean, cov=cov, size=n_data)
        x_ = pd.DataFrame(x_, columns=['age','income','savings','credit_amount_perc'])
        beta_params={'age': {'a': 2.0,'b': 5.0}, 
                     'income':{'a':2.0, 'b': 2.0}, 
                     'savings':{'a':5.0,'b':1.0}, 
                     'credit_amount_perc':{'a':0.5,'b': 0.5}}
        for c in x_.columns:
            x_[c] = scipy.stats.beta.ppf(scipy.stats.norm.cdf(x_[c].values), **beta_params[c])
        result = x_
        #result = {}
        #result['age'] = np.random.beta(a=2.0,b=5.0, size=n_data)
        #result['income'] = np.random.beta(a=2.0, b=2.0, size=n_data)
        #result['savings'] = np.random.uniform(low=0.0, high=1.0)
        #result['credit_amount_perc'] = np.random.uniform(low=0.5,high=5.0, size=n_data)

        region = [None]*3
        for i in range(len(region)):
            region[i] = np.zeros((n_data,))
        _tmp = np.random.randint(low=0, high=len(region), size=n_data)
        for i in range(_tmp.shape[0]):
            region[_tmp[i]][i] = 1
        for i in range(len(region)):
            result[f'region_{str(i)}'] = region[i]
        result['regime'] = constant
        df = pd.DataFrame(result)


        default_prob = CreditDefaultData._predict(df)
        df['default_prob'] = default_prob
        tmp = np.random.uniform(low=0.0,high=1.0, size=n_data)
        defaulted = np.zeros((n_data,))
        defaulted[tmp<default_prob] = 1.0
        df['defaulted'] = defaulted
        return df
    
    
    @staticmethod
    def _predict(df: pd.DataFrame)->np.ndarray:
        """This method computes the pd and is called by the method sample.

        Args:
            df (pd.DataFrame): Pandas DataFrame as constructed within the sample method.

        Returns:
            np.ndarray: Vector of default probabilities.
        """
        beta0 = [0.5, 1.1, 0.7]
        tmp =  (0.5-df['age'])**2 - 0.3*df['credit_amount_perc']#
        x0 = 5.0*(0.5 * df['region_0'] + 1.1 * df['region_1'] + 0.7*df['region_2'])*tmp
        x1 = 1.5*(df['income'])**2
        x2 = 1.5*df['savings']
        x3 = df['regime']
        return 1.0/(1.0+np.exp(2.0*(x0+x1+x2+x3)))